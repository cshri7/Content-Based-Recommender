A constructor is a special method in a class which is used to construct an instance of the class. The constructor can perform initialization for the object, beyond that which the Java VM does automatically. For example, Java will automatically initialize the fields point0 and point1 to null. Code section 2.4: The constructor for the class1 public Distance(int x0, int y0, int x1, int y1) {2    point0 = new java.awt.Point(x0, y0);3    point1 = new java.awt.Point(x1, y1);4 } The constructor above consists of five parts: This constructor accepts four parameters, named x0, y0, x1 and y1. Each parameter requires a parameter type declaration, which in this example is int for all four parameters. The parameters in the parameter list are separated by commas. The two assignments in this constructor use Java's new operator to allocate two java.awt.Point objects. The first allocates an object representing the first point, (x0, y0), and assigns it to the point0 instance variable (replacing the null value that the instance variable was initialized to). The second statement allocates a second java.awt.Point instance with (x1, y1) and assigns it to the point1 instance variable. This is the constructor for the Distance class. Distance implicitly extends from java.lang.Object. Java inserts a call to the super constructor as the first executable statement of the constructor if there is not one explicitly coded. The above constructor body is equivalent to the following body with the explicit super constructor call: Code section 2.5: Super constructor.1 {2    super();3    point0 = new java.awt.Point(x0, y0);4    point1 = new java.awt.Point(x1, y1);5 } While it is true that this class could be implemented in other ways, such as simply storing the coordinates of the two points and computing the distance as (x1x0)2+(y1y0)2{\displaystyle {\sqrt {(x_{1}-x_{0})^{2}+(y_{1}-y_{0})^{2}}}}, this class instead uses the existing java.awt.Point class. This choice matches the abstract definition of this class: to print the distance between two points on the plane. We take advantage of existing behavior already implemented in the Java platform rather than implementing it again. We will see later how to make the program more flexible without adding much complexity, because we choose to use object abstractions here. However, the key point is that this class uses information hiding. That is, how the class stores its state or how it computes the distance is hidden. We can change this implementation without altering how clients use and invoke the class.