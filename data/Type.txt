When an object is created, a reference to the object is also created. The object can not be accessed directly in Java, only through this object reference. This object reference has a type assigned to it. We need this type when passing the object reference to a method as a parameter. Java does strong type checking. Type is basically a list of features/operations, that can be performed through that object reference.  The object reference type is basically a contract that guarantees that those operations will be there at run time. When a car is created, it comes with a list of features/operations listed in the user manual that guarantees that those will be there when the car is used. When you create an object from a class by default its type is the same as its class. It means that all the features/operations the class defined are there and available, and can be used. See below: Code section 3.82: Default type.1 (new ClassName()).operations(); You can assign this to a variable having the same type as the class: Code section 3.83: A variable having the same type as the class.1 ClassName objRefVariable = new ClassName();2 objRefVariable.operations(); You can assign the created object reference to the class, super class, or to an interface the class implements: Code section 3.84: Using the super class.1 SuperClass objectRef = new ClassName(); // features/operations list are defined by the SuperClass class2 ...3 Interface inter = new ClassName(); // features/operations list are defined by the interface In the car analogy, the created car may have different Types of drivers. We create separate user manuals for them, an Average user manual, a Power user manual, a Child user manual, or a Handicapped user manual. Each type of user manual describes only those features/operations appropriate for the type of driver.  For instance, the Power driver may have additional gears to switch to higher speeds, that are not available to other type of users... When the car key is passed from an adult to a child we are replacing the user manuals, that is called Type Casting. In Java, casts can occur in three ways: up casting going up in the inheritance tree, until we reach the Object up casting to an interface the class implements down casting until we reach the class the object was created from Autoboxing and unboxing, language features since Java 1.5, make the programmer's life much easier when it comes to working with the primitive wrapper types. Consider this code fragment: Code section 3.85: Traditional object creation.1 int age = 23;2 Integer ageObject = new Integer(age); Primitive wrapper objects were Java's way of allowing one to treat primitive data types as though they were objects. Consequently, one was expected to wrap one's primitive data type with the corresponding primitive wrapper object, as shown above. Since Java 1.5, one may write as below and the compiler will automatically create the wrap object. The extra step of wrapping the primitive is no longer required. It has been automatically boxed up on your behalf: Code section 3.86: Autoboxing.1 int age = 23;2 Integer ageObject = age; Keep in mind that the compiler still creates the missing wrapper code, so one doesn't really gain anything performance-wise. Consider this feature a programmer convenience, not a performance booster. Each primitive type has a class wrapper: Primitive typeClass wrapperbytejava.lang.Bytechar java.lang.Charactershort java.lang.Shortintjava.lang.Integerlongjava.lang.Longfloatjava.lang.Floatdoublejava.lang.Doublebooleanjava.lang.Booleanvoidjava.lang.Void Unboxing uses the same process in reverse. Study the following code for a moment. The if statement requires a boolean primitive value, yet it was given a Boolean wrapper object. No problem! Java 1.5 will automatically unbox this. Code section 3.87: Unboxing.1 Boolean canMove = new Boolean(true);2  3 if (canMove) {4   System.out.println("This code is legal in Java 1.5");5 } Test your knowledgeQuestion 3.11: Consider the following code:Question 3.11: Autoboxing/unboxing.5 Integer a = 10;6 Integer b = a + 2;7 System.out.println(b);How many autoboxings and unboxings are there in this code?AnswerAnswer 3.11: Autoboxing/unboxing.1 Integer a = 10;2 Integer b = a + 2;3 System.out.println(b);31 autoboxing at line 1 to assign.1 unboxing at line 2 to do the addition.1 autoboxing at line 2 to assign.No autoboxing nor unboxing at line 3 as println() supports the Integer class as parameter.