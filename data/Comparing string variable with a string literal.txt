When you compare a variable with a string literal, most of people would do that this way: Code section 6.15: Bad comparison.1 if (state.equals("OK")) {2   ...3 } Always put the string literal first: Code section 6.16: Better comparison.1 if ("OK".equals(state)) {2   ...3 } If the state variable is null, you get a NullPointerException in the first example, but not in the second one. This means not doing things like: Code section 6.17: Declaring an exception. 1 String s = null; 2 while (something) { 3     if (something2) { 4         s = "yep"; 5     } 6 } 7  8 if (s != null) { 9     something3(s);10 } You can replace this with: Code section 6.18: Declaring an exception.1 boolean done = false;2 3 while (!done && something) {4     if (something2) {5        done = true;6        something3("yep");7     }8 } You might also consider replacing null with "" in the first example, but default values bring about bugs caused by default values being left in place.  A NullPointerException is actually better, as it allows the runtime to tell you about the bug, rather than just continue with a default value. An array created using new Object[10] has 10 null pointers.  That's 10 more than we want, so use collections instead, or explicitly fill the array at initialization with: Code section 6.19: Declaring an exception.1 Object[] objects = {"blah", 5, new File("/usr/bin")}; or: Code section 6.20: Declaring an exception.1 Object[] objects;2 objects = new Object[]{"blah", 5, new File("/usr/bin")}; Many methods that can return a reference null reference.  Make sure you check these.  For example: Code section 6.21: Declaring an exception.1 File file = new File("/etc");2 File[] files = file.listFiles();3 if (files != null) {4     stuff5 } File.listFiles() can return null if /etc is not a directory. You can decide to trust some methods not to return null, if you like, but that's an assumption you're making.  Some methods that don't specify that they might return null, actually do, instead of throwing an exception.