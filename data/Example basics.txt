Let's start with the basics. According to the Event Model rules, we must define an event class to encapsulate our interesting event. We should call this class something-somethingEvent. Let's go for NumberReadEvent, since that's what will interest us. According to the Model rules, this class should encapsulate any state that belongs with an event occurrence. In our case, that's the number read from the stream. And our event class must inherit from java.util.EventObject. So all in all, the following class is all we need: Code listing 1.1: NumberReadEvent.package org.wikibooks.en.javaprogramming.example;import java.util.EventObject;public class NumberReadEvent extends EventObject {    private double number;       public NumberReadEvent(Object source, Double number) {        super(source);        this.number = number;    }    public double getNumber() {        return number;    }} Next, we must define a listener interface. This interface must define methods for interesting events and must extend java.util.EventListener. We said earlier our interesting events were "number read" and "end of stream reached", so here we go: Code listing 1.2: NumberReadListener.package org.wikibooks.en.javaprogramming.example;import java.util.EventListener;public interface NumberReadListener extends EventListener {    public void numberRead(NumberReadEvent numberReadEvent);       public void numberStreamTerminated(NumberReadEvent numberReadEvent);} Actually the numberStreamTerminated method is a little weird, since it isn't actually a "number read" event. In a real program you'd probably want to do this differently. But let's keep things simple in this example.