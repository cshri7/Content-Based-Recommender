The Java language provides special support for the string concatenation with operator +: Code section 3.84: Examples of concatenation.1 System.out.println("First part");2 System.out.println(" second part");3 String str = "First part" + " second part";4 System.out.println(str);Output for Code section 3.84First part second partFirst part second part The concatenation is not always processed at the same time. Raw string literals concatenation is done at compile time, hence there is a single string literal in the byte code of the class. Concatenation with at least one object is done at runtime. + operator can concatenate other objects with strings. For instance, integers will be converted to strings before the concatenation: Code section 3.85: Concatenation of integers.1 System.out.println("Age=" + 25);Output for Code section 3.85Age=25 Each Java object has the String toString() inherited from the Object class. This method provides a way to convert objects into Strings. Most classes override the default behavior to provide more specific (and more useful) data in the returned String: Code section 3.86: Concatenation of objects.1 System.out.println("Age=" + new Integer(31));Output for Code section 3.86Age=31 Remember that String objects are immutable objects. Once a String is created, it can not be modified, takes up memory until garbage collected. Be careful of writing a method like this: Code section 3.87: Raw concatenation.1 public String convertToString(Collection<String> words) {2   String str = "";3   // Loops through every element in words collection4   for (String word : words) {5     str = str + word + " ";6   }7   return str;8 } On the + operation a new String object is created at each iteration. Suppose words contains the elements ["Foo", "Bar", "Bam", "Baz"]. At runtime, the method creates thirteen Strings: Even though only the last one is actually useful. To avoid unnecessary memory use like this, use the StringBuilder class. It provides similar functionality to Strings, but stores its data in a mutable way. Only one StringBuilder object is created. Also because object creation is time consuming, using StringBuilder produces much faster code. Code section 3.88: Concatenation with StringBuilder.1 public String convertToString(Collection<String> words) {2   StringBuilder buf = new StringBuilder();3   // Loops through every element in words collection4   for (String word : words) {5     buf.append(word);6     buf.append(" ");7   }8   return buf.toString();9 } As StringBuilder isn't thread safe (see the chapter on Concurrency) you can't use it in more than one thread. For a multi-thread environment, use StringBuffer instead which does the same and is thread safe. However, StringBuffer is slower so only use it when it is required. Moreover, before Java 5 only StringBuffer existed.