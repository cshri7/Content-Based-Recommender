In the JNI framework, native functions are implemented in separate .c or .cpp files. C++ provides a slightly simpler interface with JNI. When the JVM invokes the function, it passes a JNIEnv pointer, a jobject pointer, and any Java arguments declared by the Java method. A JNI function may look like this:  JNIEXPORT void JNICALL Java_ClassName_MethodName   (JNIEnv *env, jobject obj) {     /*Implement Native Method Here*/ } The env pointer is a structure that contains the interface to the JVM.  It includes all of the functions necessary to interact with the JVM and to work with Java objects.  Example JNI functions are converting native arrays to/from Java arrays, converting native strings to/from Java strings, instantiating objects, throwing exceptions, etc.  Basically, anything that Java code can do can be done using JNIEnv, albeit with considerably less ease. On Linux and Solaris platforms, if the native code registers itself as a signal handler, it could intercept signals intended for the JVM.  Signal chaining should be used to allow native code to better interoperate with JVM. On Windows platforms, Structured Exception Handling (SEH) may be employed to wrap native code in SEH try/catch blocks so as to capture machine (CPU/FPU) generated software interrupts (such as NULL pointer access violations and divide-by-zero operations), and to handle these situations before the interrupt is propagated back up into the JVM (i.e. Java side code), in all likelihood resulting in an unhandled exception. For example, the following converts a Java string to a native string:  extern "C" JNIEXPORT void JNICALL Java_ClassName_MethodName   (JNIEnv *env, jobject obj, jstring javaString) {     //Get the native string from javaString     const char *nativeString = env->GetStringUTFChars(javaString, 0);     //Do something with the nativeString     //DON'T FORGET THIS LINE!!!     env->ReleaseStringUTFChars(javaString, nativeString); } The JNI framework does not provide any automatic garbage collection for non-JVM memory resources allocated by code executing on the native side. Consequently, native side code (such as C, C++, or assembly language) must assume the responsibility for explicitly releasing any such memory resources that it itself acquires.