A try/catch statement can contain several catch blocks, to handle different exceptions in different ways. Each catch block must take a parameter of a different throwable class. A thrown object may match several catch block but only the first catch block that matches the object will be executed. A catch-block will catch a thrown exception if and only if: the thrown exception object is the same as the exception object specified by the catch-block. the thrown exception object is the subtype of the exception object specified by the catch-block. This means that the catch block order is important. As a consequence, you can't put a catch block that catches all the exception (which take a java.lang.Exception as parameter) before a catch block that catches a more specific exception as the second block could never be executed. Code section 6.6: Exception handling with catch blocks. 1 try { 2   // Suppose the code here throws any exceptions, 3   // then each is handled in a separate catch block. 4  5   int[] tooSmallArray = new int[2]; 6   int outOfBoundsIndex = 10000; 7   tooSmallArray[outOfBoundsIndex] = 1; 8  9   System.out.println("No exception thrown.");10 } catch(NullPointerException ex) {11   System.out.println("Exception handling code for the NullPointerException.");12 } catch(NumberFormatException ex) {13   System.out.println("Exception handling code for the NumberFormatException.");14 } catch(ArithmeticException | IndexOutOfBoundsException ex) {15   System.out.println("Exception handling code for ArithmeticException"16     + " or IndexOutOfBoundsException.");17 } catch(Exception ex) {18   System.out.println("Exception handling code for any other Exception.");19 }Output for Code section 6.6Exception handling code for ArithmeticException or IndexOutOfBoundsException. At line 14, we use a multi-catch clause. It is available since the JDK 7. This is a combination of several catch clauses and let's you handle exceptions in a single handler while also maintaining their types. So, instead of being boxed into a parent Exception super-class, they retain their individual types. You can also use the java.lang.Throwable class here, since Throwable is the parent class for the application-specific Exception classes. However, this is discouraged in Java programming circles. This is because Throwable happens to also be the parent class for the non-application specific Error classes which are not meant to be handled explicitly as they are catered for by the JVM itself.