The box 6.1 below talks about the various exception classes within the java.lang package. Box 6.1: The Java exception classesThrowableThe Throwable class is the superclass of all errors and exceptions in the Java language. Only objects that are instances of this class (or one of its subclasses) are thrown by the Java Virtual Machine or can be thrown by the Java throw statement.A throwable contains a snapshot of the execution stack of its thread at the time it was created. It can also contain a message string that gives more information about the error. Finally, it can contain a cause: another throwable that caused this throwable to get thrown. The cause facility was added in release 1.4. It is also known as the chained exception facility, as the cause can, itself, have a cause, and so on, leading to a "chain" of exceptions, each caused by another.ErrorAn Error indicates serious problems that a reasonable application should not try to handle. Most such errors are abnormal conditions.ExceptionThe class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to handle. Also this is the class that a programmer may want to extend when adding business logic exceptions.RuntimeExceptionRuntimeException is the superclass of those exceptions that can be thrown during the normal operation of the Java Virtual Machine. A method is not required to declare in its throws clause any subclasses of RuntimeException that might be thrown during the execution of the method but not caught.Figure 6.2: The exception classes and their inheritance model in the JCL. By default, when an exception is thrown, the current method is interrupted, the calling method is interrupted too and so on till the main method. A thrown exception can also be caught using atry/catch statement. Below is how a try/catch statement works: Code section 6.3: Division into a try block. 1 int a = 4; 2 int b = 2; 3 int result = 0; 4 try { 5   int c = a / b; 6   result = c; 7 } catch(ArithmeticException ex) { 8   result = 0; 9 }10 return result; The executed code lines have been highlighted. When no exception is thrown, the method flow executes the try statement and not the catch statement. Code section 6.4: Catching 'division by zero' errors. 1 int a = 4; 2 int b = 0; 3 int result = 0; 4 try { 5   int c = a / b; 6   result = c; 7 } catch(ArithmeticException ex) { 8   result = 0; 9 }10 return result; As there is a thrown exception at line 5, the line 6 is not executed, but the exception is caught by the catch statement so the catch block is executed. The following code is also executed. Note that the catch statement takes an exception as parameter. There is a third case: when the exception is not from the same class as the parameter: Code section 6.5: Uncaught exception. 1 int a = 4; 2 int b = 0; 3 int result = 0; 4 try { 5   int c = a / b; 6   result = c; 7 } catch(NullPointerException ex) { 8   result = 0; 9 }10 return result; It is as if there is no try/catch statement. The exception is thrown to the calling method.